/* SUBQUERY 실습 */
--1) 각 직원 급여가 부서별 평균 급여보다 높은 직원들의 이름과 급여
SELECT EMP_NAME, SALARY,DEPT_CODE
FROM EMPLOYEE E1
WHERE E1.SALARY >= (SELECT AVG (SALARY) 
FROM EMPLOYEE E2
--WHERE E2.DEPT_CODE = E1.DEPT_CODE
GROUP BY DEPT_CODE);

SELECT DEPT_CODE,AVG (SALARY)
FROM EMPLOYEE E2
GROUP BY DEPT_CODE;


--3) D5 부서의 평균 급여보다 높은 급여를 받는 직원들의 이름 조회
SELECT EMP_NAME, SALARY FROM EMPLOYEE
WHERE SALARY >= (SELECT AVG(SALARY) FROM EMPLOYEE WHERE DEPT_CODE='D5');

--4) 급여 300 이상인 직원 중 가장 낮은 급여 직원 이름과 급여
SELECT  EMP_NAME, SALARY FROM EMPLOYEE
WHERE SALARY = (SELECT MIN(SALARY) FROM EMPLOYEE WHERE SALARY>=3000000);


--SELECT 에서 작성하는 서브쿼리
--예시 3
-- 각 직급 이름별로 평균 급여 조회

SELECT JOB_NAME, (SELECT AVG(SALARY) FROM EMPLOYEE E
WHERE E.JOB_CODE = J.JOB_CODE
GROUP BY E.JOB_CODE) FROM JOB J;

SELECT JOB_NAME, (SELECT AVG(SALARY)  FROM EMPLOYEE E WHERE E.JOB_CODE = J.JOB_CODE ) FROM JOB J;


/* SELECT 서브 쿼리 실습 */
-- 부서 별 보너스 율 0.2 이상인 직원 수
SELECT D.DEPT_TITLE,  (SELECT COUNT(*) FROM EMPLOYEE E WHERE E.BONUS >=0.2 AND E.DEPT_CODE = D.DEPT_ID) "BONUS COUNT"
FROM DEPARTMENT D;

-- 부서별 최대 최소 급여
SELECT DEPT_TITLE "부서 명", (SELECT MAX(SALARY) FROM EMPLOYEE E WHERE E.DEPT_CODE = D.DEPT_ID) "최대 급여", (SELECT MIN(SALARY) FROM EMPLOYEE E WHERE E.DEPT_CODE = D.DEPT_ID) "최소 급여"
FROM DEPARTMENT D;

-- 부서별 직원수 조회
SELECT DEPT_TITLE "부서 명", (SELECT COUNT(*) FROM EMPLOYEE E WHERE E.DEPT_CODE = D.DEPT_ID) "인원 수"
FROM DEPARTMENT D;

--부서별 직원수 5명 이상인 부서의 부서명과 직원 수 조회

SELECT DEPT_TITLE "부서 명", (SELECT COUNT(*) FROM EMPLOYEE E WHERE E.DEPT_CODE = D.DEPT_ID) AS "직원 수"
FROM DEPARTMENT D
WHERE (SELECT COUNT(*) FROM EMPLOYEE E WHERE E.DEPT_CODE = D.DEPT_ID) >=5;

-- 6. 부서별 입사일이 가장 빠른 사원의
-- 사번, 이름, 부서명(NULL이면 '소속없음'), 직급명, 입사일을 조회하고
-- 입사일이 빠른 순으로 조회하시오
-- 단, 퇴사한 직원은 제외하고 조회..

오늘

사용자 수신자 차명준 (DM) 1:38 PM
COMPANY_ID, CONSTRAINT CID_FK FOREIGN KEY (COMPANY_ID) REFERENCES COMPANY(COMPANY_ID) ON DELETE CASCADE

사용자 수신자 차명준 (DM) 1:43 PM
CREATE TABLE SNACKS(
    SNACK_ID NUMBER(10,0),
    SNACK_NAME VARCHAR2(100),
    PRICE NUMBER(10,2),
    COMPANY_ID, CONSTRAINT CID_FK FOREIGN KEY (COMPANY_ID) REFERENCES COMPANY(COMPANY_ID) ON DELETE CASCADE
    );

사용자 수신자 오재진 (DM) 2:02 PM
앗 형님
저도 안풀어본 문제라
풀어보고 알려드리겠습니다!

사용자 수신자 성혁 권 (DM) 2:32 PM
-- 6. 부서별 입사일이 가장 빠른 사원의
-- 사번, 이름, 부서명(NULL이면 '소속없음'), 직급명, 입사일을 조회하고
-- 입사일이 빠른 순으로 조회하시오
-- 단, 퇴사한 직원은 제외하고 조회..

SELECT DISTINCT EMP_ID, EMP_NAME, NVL2(E.DEPT_CODE,(SELECT DEPT_TITLE  FROM DEPARTMENT WHERE DEPT_ID = E.DEPT_CODE)
,'소속없음') "부서명" ,E.HIRE_DATE "입사일", JOB_NAME "직급명"
FROM EMPLOYEE E , (
SELECT DEPT_CODE,MIN(HIRE_DATE)AS HIRE_DATE
FROM EMPLOYEE
WHERE ENT_YN='N'
GROUP BY DEPT_CODE
) E2, DEPARTMENT D, JOB J
WHERE e.hire_date = E2.hire_date
AND E.JOB_CODE = J.JOB_CODE
ORDER BY E.HIRE_DATE;


SELECT EMP_NAME, SALARY,  
NVL(SALARY*BONUS,0) "보너스*봉급"
FROM EMPLOYEE;

SELECT E.EMP_ID, E.EMP_NAME, NVL(D.DEPT_TITLE, '소속 없음'), J.JOB_NAME, E.HIRE_DATE 
FROM EMPLOYEE E, DEPARTMENT D, JOB J
WHERE E.DEPT_CODE = D.DEPT_ID AND E.JOB_CODE = J.JOB_CODE
AND E.HIRE_DATE = (SELECT MIN(E.HIRE_DATE) FROM EMPLOYEE E WHERE E.DEPT_CODE = D.DEPT_ID AND E.ENT_YN='N') 
ORDER BY E.HIRE_DATE;



-- 7. 직급별 나이가 가장 어린 직원의
-- 사번, 이름, 직급명, 나이, 보너스 포함 연봉을 조회하고
-- 나이순으로 내림차순 정렬하세요
-- 단 연봉은 \124,800,000 으로 출력되게 하세요. (\ : 원 단위 기호)

SELECT EMP_ID, EMP_NAME, JOB_NAME, 2024 - TO_NUMBER('19'||SUBSTR(E.EMP_NO,1,2)) "나이",  TO_CHAR(SALARY*(1+NVL(BONUS,0))*12,'L999,999,999') "보너스 포함 연봉"
FROM EMPLOYEE E,JOB J,
(SELECT JOB_CODE, MAX(EMP_NO) EMP_NO FROM EMPLOYEE GROUP BY JOB_CODE) J2
WHERE E.JOB_CODE = J.JOB_CODE AND E.JOB_CODE = J2.JOB_CODE
AND E.EMP_NO =J2.EMP_NO
ORDER BY 나이 DESC;

SELECT 

